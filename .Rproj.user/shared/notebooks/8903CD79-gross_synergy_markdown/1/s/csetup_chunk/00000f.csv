"0","knitr::opts_chunk$set(echo = TRUE)"
"0",""
"0","#' **************************************************************************************"
"0","#' **************************************************************************************"
"0",""
"0","#' Function 1"
"0","#' This function cleans the indicator data. The processes is as follows:"
"0","#' Recursively: "
"0","#' 1. Filter the countries by name and extract their data. "
"0","#' 2. Add their data to a new data frame."
"0","#' 3. Add the new data frame to a list "
"0","#' @param sdg_ind_unclean_list is a list of unclean data"
"0","#' @return a list of cleaned data-frames with each column representing each country"
"0","#' and each row an observation of a specific indicator value for each country."
"0","clean_indicator_data_fun <- function(sdg_ind_unclean_list) {"
"0","  #' find indicators that have more than one attribute."
"0","  num_more_than_one_att <- c()"
"0","  for(i in 1:length(sdg_ind_unclean_list)) {"
"0","    if (ncol(sdg_ind_unclean_list[[i]]) > 4) {"
"0","      num_more_than_one_att <- rbind(num_more_than_one_att, i)"
"0","      print(i)"
"0","    }"
"0","  }"
"0","  if (length(num_more_than_one_att) != 0) {"
"0","    sdg_ind_unclean_list[[num_more_than_one_att]] <- NULL #remove them"
"0","  }"
"0","  "
"0","  #' The unclean data has four columns. "
"0","  #' The fourth column is the data, associated to the country in the second column,"
"0","  #' for the observation date in first column. "
"0","  #' Recursively: "
"0","  #' 1. Filter the countries by name and extract their data. "
"0","  #' 2. Add their data to a new data frame."
"0","  #' 3. Add the new data frame to a list "
"0","  sdg_indicator_selected_for_countries <- list()"
"0","  for (j in 1:length(sdg_ind_unclean_list)) {"
"0","    temp_ind_df <- data.frame()"
"0","    for (i in 1:length(COUNTRY_NAMES)) {"
"0","      temp_ind_data <- ((sdg_ind_unclean_list[[j]] %>% "
"0","                           filter(Entity == COUNTRY_NAMES[i] & Year >= YEAR_THRESHOLD) %>%"
"0","                           complete(Year = YEAR_SEQUENCE))[,4] %>% data.frame())[,1]"
"0","      temp_ind_df <- rbind(temp_ind_df, temp_ind_data)"
"0","    }"
"0","    temp_ind_df <- (t(temp_ind_df))"
"0","    temp_ind_df <- normalize_fun(temp_ind_df)"
"0","    colnames(temp_ind_df) <- gsub(pattern = "" "", replacement = ""_"", tolower(COUNTRY_NAMES))"
"0","    rownames(temp_ind_df) <- YEAR_SEQUENCE"
"0","    sdg_indicator_selected_for_countries[[j]] <- temp_ind_df"
"0","  }"
"0","  "
"0","  names(sdg_indicator_selected_for_countries) <- names(sdg_ind_unclean_list)"
"0","  print(names(sdg_indicator_selected_for_countries))"
"0","  return(sdg_indicator_selected_for_countries)"
"0","}"
"0",""
"0","#' Function 2"
"0","#' This function evaluates the distribution of positive gross synergy"
"0","#' @param syn_df synergy "
"0","#' @return positive contributions of gross synergy "
"0","synergy_dist_fun <- function(syn_df) {"
"0","  "
"0","  Pos_Count <- colSums(syn_df[,1:ncol(syn_df)] > 0, na.rm = TRUE)"
"0","  Neg_Count <- colSums(syn_df[,1:ncol(syn_df)] < 0, na.rm = TRUE)"
"0","  syn_df_count <- Pos_Count / (Pos_Count + Neg_Count) * 100"
"0","  "
"0","  return(data.frame(t(syn_df_count)))"
"0","}"
"0",""
"0","#' Function 3"
"0","#' This function creates a contribution data-frame for each indicator. Each data-frame has "
"0","#' countries as columns, years as rows, and each observation is the contribution to gross synergy "
"0","#' of the indicator. The contributions are normalized in range -100% to 100%. "
"0","#' @param contribution_list is a list of country contributions to indicators"
"0","#' @param indicator_names is a vector of indicator names"
"0","country_cont_fun <- function(contribution_list, ind_names) {"
"0","  indicator_contirbutions_by_country <- list()"
"0","  "
"0","  for (i in 1:length(ind_names)) {"
"0","    temp_df <- data.frame()"
"0","    for (j in 1:length(contribution_list)) {"
"0","      temp_df <- rbind(temp_df, contribution_list[[j]][,ind_names[i]])"
"0","    }"
"0","    temp_df <- data.frame(t(temp_df))"
"0","    colnames(temp_df) <- COUNTRY_NAMES"
"0","    rownames(temp_df) <- as.Date(ISOdate(NEW_YEAR_SEQ, 1, 1))  # beginning of year"
"0","    indicator_contirbutions_by_country[[i]] <- temp_df"
"0","  }"
"0","  "
"0","  norm_indicator_contirbutions_by_country <- list()"
"0","  for (i in 1:length(ind_names)) {"
"0","    dd <- indicator_contirbutions_by_country[[i]]"
"0","    new_dd <- data.frame()"
"0","    for (j in 1:nrow(dd)) {"
"0","      new_dd <- rbind(new_dd, as.matrix(dd[j,]))"
"0","    }"
"0","    norm_indicator_contirbutions_by_country[[i]] <- new_dd"
"0","  }"
"0","  "
"0","  names(norm_indicator_contirbutions_by_country) <- ind_names"
"0","  "
"0","  return(norm_indicator_contirbutions_by_country)"
"0","}"
"0",""
"0","#' Function 4"
"0","#' This function normalizes the synergy contribution rows that are larger than 100 and less than -100"
"0","#' to be in between -100 and 100. We use absolute value to consider both bounds."
"0","#' @param cont_list is the synergy contribution list by each SDG"
"0","#' @param val_larger_than is the threshold for normalization"
"0","make_between_neg_pos_100 <- function(cont_list, val_larger_than) {"
"0","  for (i in 1:length(cont_list)) {"
"0","    x <- cont_list[[i]]"
"0","    ind <- sort(unique(row(x)[which(abs(x) > val_larger_than)]))"
"0","    "
"0","    if (!(is.integer(ind) && length(ind) == 0L)) {"
"0","      y = data.frame(t(apply(x[ind,], 1, function(x) x / max(abs(x))))) * 100 "
"0","      x[ind,] = y"
"0","    }"
"0","    "
"0","    cont_list[[i]] <- x"
"0","  }"
"0","  return(cont_list)"
"0","}"
"0",""
"0","#' FUNCTION 5"
"0","#' This function appends the synergy contributions for all SDG indicators into a "
"0","#' large data frame."
"0","#' @param cont_list is the synergy contribution list by each SDG"
"0","#' @return a large data frame with all the SDG synergy contributions for countries"
"0","create_all_cont <- function(cont_list) {"
"0","  x <- data.frame()"
"0","  for (i in 1:length(cont_list)) {"
"0","    x1 <- cont_list[[i]]"
"0","    new_df_names <- c(""Indicator"", ""Year"", colnames(x1))"
"0","    x1 <- cbind(rep(names(cont_list)[i], nrow(x1)), "
"0","                format(as.Date(row.names(x1)), ""%Y""),"
"0","                x1)"
"0","    colnames(x1) <- new_df_names"
"0","    row.names(x1) <- NULL"
"0","    "
"0","    "
"0","    x <- rbind.data.frame(x, x1)"
"0","  }"
"0","  return(x)"
"0","}"
"0",""
"0","#' Function 6"
"0","#' Equation 1"
"0","#' This function normalizes entire data-frame of indicator values for group of countries."
"0","#' @param x is the data-frame to be normalized."
"0","#' @return a normalized data-frame."
"0","normalize_fun <- function(x) {"
"0","  norm_x <- as.matrix(x)"
"0","  return(data.frame(rescale(x, c(0,1))))"
"0","}"
"0",""
"0","#' Function 7"
"0","#' Equation 2"
"0","#' Equation 3"
"0","#' This function uses the cleaned data-frames to evaluate domestic changes for a single country"
"0","#' from the list of countries provided by the user."
"0","#' @param sdg_ind_clean_list is he list of cleaned data-frames"
"0","#' @return an impact matrix with each row representing the observation date, and"
"0","#' each column the impact of an indicator."
"0","evaluate_dist_individual_fun <- function(sdg_ind_clean_list) {"
"0","  country_list <- gsub(pattern = "" "", replacement = ""_"", tolower(COUNTRY_NAMES))"
"0","  country_dist_mat_list <- list()"
"0","  for(j in 1:length(country_list)) {"
"0","    cc <- data.frame()"
"0","    for (i in 1:length(sdg_ind_clean_list)) {"
"0","      dd <- sdg_ind_clean_list[[i]][country_list[j]]"
"0","      one_dist_indicator <- sqrt(rowSums(diff(as.matrix(dd))^2, na.rm = TRUE))"
"0","      cc <- rbind(cc, one_dist_indicator)"
"0","    }"
"0","    cc <- data.frame(t(cc))"
"0","    colnames(cc) <- names(sdg_ind_clean_list)"
"0","    rownames(cc) <- as.Date(ISOdate(YEAR_SEQUENCE[-1], 1, 1))  # beginning of year"
"0","    cc$year <- YEAR_SEQUENCE[-1]"
"0","    cc$year <- NULL"
"0","    country_dist_mat_list[[j]] <- cc"
"0","  }"
"0","  names(country_dist_mat_list) <- country_list"
"0","  return(country_dist_mat_list)"
"0","}"
"0",""
"0","#' Function 8"
"0","#' Equation 4"
"0","#' Equation 5"
"0","#' This function uses the cleaned data-frames to evaluate foreign changes for a group of"
"0","#' countries provided by the user."
"0","#' @param sdg_ind_clean_list is he list of cleaned data-frames"
"0","#' @return an impact matrix with each row representing the observation date, and"
"0","#' each column the impact of an indicator."
"0","evaluate_dist_group_fun <- function(sdg_ind_clean_list) {"
"0","  cc <- data.frame()"
"0","  for (i in 1:length(sdg_ind_clean_list)) {"
"0","    dd <- sdg_ind_clean_list[[i]]"
"0","    one_dist_indicator <- sqrt(rowSums(diff(as.matrix(dd))^2, na.rm = TRUE))"
"0","    cc <- rbind(cc, one_dist_indicator)"
"0","  }"
"0","  cc <- data.frame(t(cc))"
"0","  colnames(cc) <- names(sdg_ind_clean_list)"
"0","  rownames(cc) <- as.Date(ISOdate(YEAR_SEQUENCE[-1], 1, 1))  # beginning of year"
"0","  cc$year <- YEAR_SEQUENCE[-1]"
"0","  #cc <- cc %>% filter(year <= 2020 & year >= 2000) #' This was the issue"
"0","  cc$year <- NULL"
"0","  return(cc)"
"0","}"
"0",""
"0","#' Function 9"
"0","#' Equation 8"
"0","#' Equation 9"
"0","#' This function uses the cleaned data-frames to evaluate difference matrix for a group of"
"0","#' countries provided by the user."
"0","#' @param sdg_ind_clean_list is he list of cleaned data-frames"
"0","#' @return an difference matrix with each row representing the observation date, and"
"0","#' each column the difference (historical change) of an indicator."
"0","evaluate_grads_group_fun <- function(sdg_ind_clean_list) {"
"0","  cc <- data.frame()"
"0","  for (i in 1:length(sdg_ind_clean_list)) {"
"0","    dd <- sdg_ind_clean_list[[i]]"
"0","    one_grads_indicator <- rowMeans(diff(as.matrix(dd)), na.rm = TRUE)"
"0","    one_grads_indicator[one_grads_indicator < 0] <- -1"
"0","    one_grads_indicator[one_grads_indicator > 0] <- 1"
"0","    cc <- rbind(cc, one_grads_indicator)"
"0","  }"
"0","  cc <- data.frame(t(cc))"
"0","  colnames(cc) <- names(sdg_ind_clean_list)"
"0","  rownames(cc) <- as.Date(ISOdate(YEAR_SEQUENCE[-1], 1, 1))  # beginning of year"
"0","  cc$year <- YEAR_SEQUENCE[-1]"
"0","  #cc <- cc %>% filter(year <= 2020 & year >= 2000) #' This was the issue"
"0","  cc$year <- NULL"
"0","  return(cc)"
"0","}"
